# üìö Custom DSA Library in C++.
___
## Why not just use STL containers? What's the goal here?
It's the low-level details that *really* spark my curiosity.
I don't **just** want to use bread and butter DSA in my programs, 
but to also demystify them for myself.

The intention is to master pointer and memory management, to
rid of the veil of abstraction and not see incomprehensible magic, but a
familiar friend.

The library *isn't* intended to be an exhaustive list,
it's to just implement whatever structure/algorithm that brings me closest to
my goal the most **efficiently**.

____
## ‚û°Ô∏è Phase 1: Low-Level Structures (Pointers, Memory)

- [ ] Singly Linked List 
- [ ] Doubly Linked List
- [ ] Circular Linked List
- [ ] Stack (using array and LL)
- [ ] Queue (using array and LL)
- [ ] Deque
- [ ] Custom smart pointer 
____
## üå≥ Phase 2: Trees and Recursion

- [ ] Binary Tree (basic traversal: in/pre/post-order)
- [ ] Binary Search Tree (insert, delete, search)
- [ ] AVL Tree (rotations + balancing)
- [ ] Heap (min/max using array)
- [ ] Trie (prefix tree for strings)
___
## ü§ñ Phase 3: Essential Algorithms

- [ ] Bubble Sort
- [ ] Insertion Sort
- [ ] Merge Sort (recursive logic)
- [ ] QuickSort (partitioning)
- [ ] Binary Search (classic + edge cases)
- [ ] Lower Bound / Upper Bound (with examples)
- [ ] Recursion patterns (subset gen, backtracking)
- [ ] DFS + BFS on trees and simple graphs
- [ ] Union-Find / Disjoint Set (with path compression)
- [ ] Dijkstra‚Äôs Algorithm (priority queue)